{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ESP32 SvelteKit - Create Amazing IoT Projects","text":"<p>A simple and extensible framework for ESP32 based IoT projects with a feature-rich, beautiful, and responsive front-end build with Sveltekit, TailwindCSS and DaisyUI. This is a project template to get you started in no time backed by a powerful back end service, an amazing front end served from the ESP32 and an easy to use build chain to get everything going.</p> <p>It was forked from the fabulous rjwats/esp8266-react project, from where it inherited the mighty back end services.</p> <p>Info</p> <p>This template repository is not meant to be used stand alone. If you're just looking for a WiFi manager there are plenty of options available. This is a starting point when you need a rich web UI.</p>"},{"location":"#features","title":"Features","text":""},{"location":"#beautiful-ui-powered-by-daisyui-and-tailwindcss","title":"Beautiful UI powered by DaisyUI and TailwindCSS","text":"<p>Beautiful, responsive UI which works equally well on desktop and on mobile. Gently animated for a snappy and modern feeling without ever being obtrusive or in the way. Easy theming with DaisyUI and media-queries to respect the users wish for a light or dark theme.</p>"},{"location":"#low-memory-footprint-and-easy-customization-by-courtesy-of-sveltekit","title":"Low Memory Footprint and Easy Customization by Courtesy of SvelteKit","text":"<p>SvelteKit is ideally suited to be served from constrained devices like an ESP32. It's unique approach leads to very slim files. No bloatware like other popular JS frameworks. Not only the low memory footprint make it ideal but the developer experience is also outstanding letting you customize the front end with ease. Adapt and add functionality as you need it. The back end has you covered as well.</p>"},{"location":"#rich-communication-interfaces","title":"Rich Communication Interfaces","text":"<p>Comes with a rich set of communication interfaces to cover most standard needs of an IoT application. Like MQTT client, HTTP RESTful API or WebSocket Server. All communication channels are stateful and fully synchronized. Changes propagate and are communicated to all other participants. The states can be persisted on the file system as well. For accurate time keeping time can by synchronized over NTP.</p>"},{"location":"#wifi-provisioning-and-management","title":"WiFi Provisioning and Management","text":"<p>Naturally ESP32 SvelteKit comes with rich features to manage all your WiFi needs. From pulling up an access point for provisioning or as fall back, to fully manage your WiFi networks. Scan for available networks and connect to them. Advanced configuration options like static IP are on board as well.</p>"},{"location":"#secured-api-and-user-management","title":"Secured API and User Management","text":"<p>Manage different user of your app with two authorization levels. An administrator and a guest user. Authenticate their API calls with a JWT token. Manage the user's profile from the admin interface. Use at own risk, as it is neither secure without the ability to use TLS/SSL encryption on the ESP32 server, nor very convenient, as only an admin can change passwords.</p>"},{"location":"#ota-upgrade-service","title":"OTA Upgrade Service","text":"<p>The framework can provide three different channels for Over-the-Air updates. Either an ArduinoOTA port for updates directly from the IDE, by uploading a *.bin file from the web interface. Or by pulling a firmware image from an update server. This is implemented with the github release page as an example.</p>"},{"location":"#automated-build-chain","title":"Automated Build Chain","text":"<p>The automated build chain takes out the pain and tears of getting all the bits and pieces play nice together. The repository contains a PlatformIO project at its heart. A SvelteKit project for the frontend code and a mkdocs project for the documentation go alongside. The PlatformIO build tools not only build the SvelteKit frontend with Vite, but also ensure that the build results are gzipped and find their way into the flash memory of the ESP32. You have two choices to serve the frontend either from the flash partition, or embedded into the firmware binary from PROGMEM. The latter is much more friendly if your frontend code should be distributed OTA as well, leaving all configuration files intact.</p>"},{"location":"#compatible-with-all-esp32-flavours","title":"Compatible with all ESP32 Flavours","text":"<p>The code runs on all variants of the ESP32 chip family. From the plain old ESP32, the ESP32-S3 and ESP32-C3. Other ESP32 variants might work, but haven't been tested. Sorry, no support for the older ESP8266. Go with one of the ESP32's instead.</p> <p>Let's get started!</p>"},{"location":"#license","title":"License","text":"<p>ESP32 SvelteKit is distributed with two licenses for different sections of the code. The back end code inherits the GNU LESSER GENERAL PUBLIC LICENSE Version 3 and is therefore distributed with said license. The front end code is distributed under the MIT License. See the LICENSE for a full text of both licenses.</p>"},{"location":"buildprocess/","title":"Build Process","text":"<p>The build process is controlled by platformio.ini and automates the build of the front end website with Vite as well as the binary compilation for the ESP32 firmware. Whenever PlatformIO is triggered with the <code>upload</code> command this process will call the python script build_interface.py to action. It will start the Vite build and gzip the resulting files either to the <code>data/</code> directory or embed them into a header file. If necessary a file system image for the flash is created for the default build environment and upload to the ESP32 prior to compiling the firmware binary.</p>"},{"location":"buildprocess/#serving-from-flash-or-progmem","title":"Serving from Flash or PROGMEM","text":"<p>The front end website can be served either from the SPIFFS partition of the flash, or embedded into the firmware binary from PROGMEM (default). Later has the advantage that only one binary needs to be distributed easing the OTA process. Further more this is desirable if you like to preserve the settings stored in the SPIFFS partition, or have other files there that need to survive a firmware update. To serve from the SPIFFS partition instead please comment the following build flag out:</p> <pre><code>build_flags =\n    ...\n    -D PROGMEM_WWW\n</code></pre>"},{"location":"buildprocess/#partitioning","title":"Partitioning","text":"<p>If you choose to serve the frontend from PROGMEM (default) it becomes part of the firmware binary. As many ESP32 modules only come with 4MB built-in flash this results in the binary being too large for the reserved flash. Therefor a partition scheme with a larger section for the executable code is selected. However, this limits the SPIFFS partition to 200kb. There are a great number of default partition tables for Arduino-ESP32 to choose from. If you have 8MB or 16MB flash this would be your first choice. If you don't need OTA you can choose a partition scheme without OTA.</p> <p>Should you want to deploy the frontend from the flash's SPIFFS partition on a 4MB chip you need to comment out the following two lines. Otherwise the 200kb will not be large enough to host the front end code.</p> <pre><code>board_build.partitions = min_spiffs.csv\n</code></pre>"},{"location":"buildprocess/#selecting-features","title":"Selecting Features","text":"<p>Many of the framework's built in features may be enabled or disabled as required at compile time. This can help save sketch space and memory if your project does not require the full suite of features. The access point and WiFi management features are \"core features\" and are always enabled. Feature selection may be controlled with the build flags defined in features.ini.</p> <p>Customize the settings as you see fit. A value of 0 will disable the specified feature:</p> <pre><code>  -D FT_SECURITY=1\n  -D FT_MQTT=1\n  -D FT_NTP=1\n  -D FT_OTA=1\n  -D FT_UPLOAD_FIRMWARE=1\n  -D FT_DOWNLOAD_FIRMWARE=1\n  -D FT_SLEEP=1\n  -D FT_BATTERY=1\n</code></pre> Flag Description FT_SECURITY Controls whether the security features are enabled. Disabling this means you won't need to authenticate to access the device and all authentication predicates will be bypassed. FT_MQTT Controls whether the MQTT features are enabled. Disable this if your project does not require MQTT support. FT_NTP Controls whether network time protocol synchronization features are enabled. Disable this if your project does not require accurate time. FT_OTA Controls whether ArduinoOTA update support is enabled. Disable this if you won't be using the remote update feature. FT_UPLOAD_FIRMWARE Controls whether the manual upload firmware feature is enabled. Disable this if you won't be manually uploading firmware. FT_DOWNLOAD_FIRMWARE Controls whether the firmware download feature is enabled. Disable this if you won't firmware pulled from a server. FT_SLEEP Controls whether the deep sleep feature is enabled. Disable this if your device is not battery operated or you don't need to place it in deep sleep to save energy. FT_BATTERY Controls whether the battery state of charge shall be reported to the clients. Disable this if your device is not battery operated. <p>In addition custom features might be added or removed at runtime. See Custom Features on how to use this in your application.</p>"},{"location":"buildprocess/#factory-settings","title":"Factory Settings","text":"<p>The framework has built-in factory settings which act as default values for the various configurable services where settings are not saved on the file system. These settings can be overridden using the build flags defined in factory_settings.ini.</p> <p>Customize the settings as you see fit, for example you might configure your home WiFi network as the factory default:</p> <pre><code>  -D FACTORY_WIFI_SSID=\\\"My Awesome WiFi Network\\\"\n  -D FACTORY_WIFI_PASSWORD=\\\"secret\\\"\n  -D FACTORY_WIFI_HOSTNAME=\\\"awesome_light_controller\\\"\n</code></pre>"},{"location":"buildprocess/#default-access-point-settings","title":"Default access point settings","text":"<p>By default, the factory settings configure the device to bring up an access point on start up which can be used to configure the device:</p> <ul> <li>SSID: ESP32-Sveltekit</li> <li>Password: esp-sveltekit</li> </ul>"},{"location":"buildprocess/#security-settings-and-user-credentials","title":"Security settings and user credentials","text":"<p>By default, the factory settings configure two user accounts with the following credentials:</p> Username Password admin admin guest guest <p>It is recommended that you change the user credentials from their defaults better protect your device. You can do this in the user interface, or by modifying factory_settings.ini as mentioned above.</p>"},{"location":"buildprocess/#customizing-the-factory-time-zone-setting","title":"Customizing the factory time zone setting","text":"<p>Changing factory time zone setting is a common requirement. This requires a little effort because the time zone name and POSIX format are stored as separate values for the moment. The time zone names and POSIX formats are contained in the UI code in timezones.ts. Take the appropriate pair of values from there, for example, for Los Angeles you would use:</p> <pre><code>  -D FACTORY_NTP_TIME_ZONE_LABEL=\\\"America/Los_Angeles\\\"\n  -D FACTORY_NTP_TIME_ZONE_FORMAT=\\\"PST8PDT,M3.2.0,M11.1.0\\\"\n</code></pre>"},{"location":"buildprocess/#placeholder-substitution","title":"Placeholder substitution","text":"<p>Various settings support placeholder substitution, indicated by comments in factory_settings.ini. This can be particularly useful where settings need to be unique, such as the Access Point SSID or MQTT client id. The following placeholders are supported:</p> Placeholder Substituted value #{platform} The microcontroller platform, e.g. \"esp32\" or \"esp32c3\" #{unique_id} A unique identifier derived from the MAC address, e.g. \"0b0a859d6816\" #{random} A random number encoded as a hex string, e.g. \"55722f94\""},{"location":"buildprocess/#other-build-flags","title":"Other Build Flags","text":""},{"location":"buildprocess/#cross-origin-resource-sharing","title":"Cross-Origin Resource Sharing","text":"<p>If you need to enable Cross-Origin Resource Sharing (CORS) on the ESP32 server just uncomment the following build flags:</p> <pre><code>build_flags =\n...\n  ; Uncomment to configure Cross-Origin Resource Sharing\n  -D ENABLE_CORS\n  -D CORS_ORIGIN=\\\"*\\\"\n</code></pre> <p>This will add the <code>Access-Control-Allow-Origin</code> and <code>Access-Control-Allow-Credentials</code> headers to any request made.</p>"},{"location":"buildprocess/#esp32-core_debug_level","title":"ESP32 <code>CORE_DEBUG_LEVEL</code>","text":"<p>The ESP32 Arduino Core and many other libraries use the ESP Logging tools. To enable these debug and error messages from deep inside your libraries uncomment the following build flag.</p> <pre><code>build_flags =\n...\n    -DCORE_DEBUG_LEVEL=5\n</code></pre> <p>It accepts values from 1 (Verbose) to 5 (Errors) for different information depths to be logged on the serial terminal.</p>"},{"location":"buildprocess/#serve-config-files","title":"Serve Config Files","text":"<p>By enabling this build flag the ESP32 will serve all config files stored on the LittleFS flash partition under <code>http:\\\\[IP]\\config\\[filename].json</code>. This can be helpful to troubleshoot problems. However, it is strongly advised to disable this for production builds.</p> <pre><code>build_flags =\n...\n  -D SERVE_CONFIG_FILES\n</code></pre>"},{"location":"buildprocess/#ssl-root-certificate-store","title":"SSL Root Certificate Store","text":"<p>Some features like firmware download require a SSL connection. For that the SSL Root CA certificate must be known to the ESP32. The build system contains a python script derived from Espressif ESP-IDF building a certificate store containing one or more certificates. In order to create the store you must uncomment the three lines below in <code>platformio.ini</code>.</p> <pre><code>extra_scripts =\n    pre:scripts/generate_cert_bundle.py\nboard_build.embed_files = src/certs/x509_crt_bundle.bin\nboard_ssl_cert_source = folder\n</code></pre> <p>The script will download a public certificate store from Mozilla, builds a binary containing all certs and embeds this into the firmware. This will add ~65kb to the firmware image. Should you only need a few known certificates you can place their <code>*.pem</code> or <code>*.der</code> files in the ssl_certs folder and change <code>board_ssl_cert_source = folder</code>. Then only these certificates will be included in the store. This is especially useful, if you only need to connect to know servers and need to shave some kb off the firmware image:</p> <p>Info</p> <pre><code>To enable SSL the feature `FT_NTP=1` must be enabled as well.\n</code></pre>"},{"location":"buildprocess/#vite-and-littlefs-32-character-limit","title":"Vite and LittleFS 32 Character Limit","text":"<p>The static files for the website are build using vite. By default vite adds a unique hash value to all filenames for improved caching performance. However, LittleFS on the ESP32 is limited to filenames with 32 characters. This restricts the number of characters available for the user to name svelte files. To give a little bit more headroom a vite-plugin removes all hash values, as they offer no benefit on an ESP32. However, have the 32 character limit in mind when naming files. Excessively long names may still cause some issues when building the LittleFS binary.</p>"},{"location":"components/","title":"Components","text":"<p>The project includes a number of components to create the user interface. Even though DaisyUI has a huge set of components, it is often beneficial to recreate them as a Svelte component. This offers a much better integration into the Svelte way of doing things, is less troublesome with animations and results in a overall better user experience.</p>"},{"location":"components/#collapsible","title":"Collapsible","text":"<p>A collapsible container to hide / show content by clicking on the arrow button.</p> <pre><code>import Collapsible from \"$lib/components/Collapsible.svelte\";\n</code></pre> <p>It exports a closed / open state with <code>export open</code> which you can use to determine the mounting behavior of the component.</p>"},{"location":"components/#slots","title":"Slots","text":"<p>The component has two slots. A named slot <code>title</code> for the collapsible title and the main slot for the content that can be hidden or shown.</p> <pre><code>&lt;Collapsible open={false} class=\"shadow-lg\" on:closed={doSomething}&gt;\n  &lt;span slot=\"title\"&gt;Title&lt;/span&gt;\n  ...\n&lt;/Collapsible&gt;\n</code></pre> <p>The <code>class</code> attribute may be used as normal to style the container. By default there is no special styling like background or shadows to accentuate the container element.</p>"},{"location":"components/#events","title":"Events","text":"<p>The collapsible component dispatches two events. <code>on:closed</code> when the collapsible is closed and <code>on:opened</code> when it is opened. You can bind to them as to any other event.</p>"},{"location":"components/#inputpassword","title":"InputPassword","text":"<p>This is an input field specifically for passwords. It comes with an \"eye\"-button on the right border to toggle the visibility of the password. It natively blends into the style from DaisyUI.</p> <pre><code>import InputPassword from \"$lib/components/InputPassword.svelte\";\n</code></pre> <p>You may use it like any other form element:</p> <pre><code>&lt;InputPassword id=\"pwd\" bind:value={password} /&gt;\n</code></pre>"},{"location":"components/#rssiindicator","title":"RSSIIndicator","text":"<p>This shows the popular WiFi strength indicator icon with differently highlighted circles depending on the received signal strength (RSSI) of the WiFi signal. In addition it can display the signal strength in raw \"dBm\" as an indicator badge.</p> <pre><code>import RssiIndicator from \"$lib/components/RSSIIndicator.svelte\";\n</code></pre> <p>Just use and style as you please. It doesn't have any slots or events.</p> <pre><code>&lt;RssiIndicator showDBm={true} rssi_dbm={-85} class=\"text-base-content h-10 w-10\" /&gt;\n</code></pre> <p>Two exports control the behavior of the component. <code>rssi_dbm</code> accepts a negative number of the raw RSSI in dBm and is used to determine how many circles of reception should be shown. An optional boolean <code>showDBm</code> (defaults to <code>false</code>) shows the indicator badge with the dBm value.</p>"},{"location":"components/#settings-card","title":"Settings Card","text":"<p>A Settings Card is in many ways similar to a collapsible. However, it is styled and is the main element of many settings menus. It also accepts an icon in a dedicate slot and unlike collapsible has no events.</p> <pre><code>import SettingsCard from \"$lib/components/SettingsCard.svelte\";\n</code></pre>"},{"location":"components/#slots_1","title":"Slots","text":"<p>Three slots are available. Besides the main slot for the content there is a named slot for the <code>title</code> and s second one for the <code>icon</code>.</p> <pre><code>&lt;SettingsCard collapsible={true} open={false}&gt;\n    &lt;Icon slot=\"icon\" class=\"lex-shrink-0 mr-2 h-6 w-6 self-end\" /&gt;\n    &lt;span slot=\"title\"&gt;Title&lt;/span&gt;\n    ...\n&lt;/SettingsCard&gt;\n</code></pre> <p>The component exports two properties to determine its behavior. <code>collapsible</code> is a boolean describing wether the component should behave like a collapsible in the first place. <code>open</code> is a boolean as well and if set true shows the full content of the body on mount.</p>"},{"location":"components/#spinner-obsolete","title":"Spinner (OBSOLETE)","text":"<p>A small component showing an animated spinner which can be used while waiting for data.</p> <pre><code>import Spinner from \"$lib/components/Spinner.svelte\";\n</code></pre> <p>No slots, no events, no properties. Just use <code>&lt;Spinner/&gt;</code> whenever something is loading.</p>"},{"location":"components/#toast-notifications","title":"Toast Notifications","text":"<p>Toast notifications are implemented as a writable store and are easy to use from any script section. They are an easy way to feedback to the user. To use them just import the notifications store</p> <pre><code>import { notifications } from \"$lib/components/toasts/notifications\";\n</code></pre> <p>and call one of the 4 toast methods:</p> Method Description <code>notification.error(msg:string, timeout:number)</code>  Shows an error message <code>notification.warning(msg:string, timeout:number)</code>  Shows a warning message <code>notification.info(msg:string, timeout:number)</code>  Shows an info message <code>notification.success(msg:string, timeout:number)</code>  Shows as success message <p>Each method takes an <code>msg</code>-string as an argument, which will be shown as the message body. It accepts HTML yo enrich your toasts, if you should desire to do so. The <code>timeout</code> argument specifies how many milliseconds the toast notification shall be shown to the user.</p>"},{"location":"components/#github-update-dialog","title":"Github Update Dialog","text":"<p>This is a modal showing the update progress, possible error messages and makes a full page refresh 5 seconds after the OTA was successful.</p>"},{"location":"components/#update-indicator","title":"Update Indicator","text":"<p>The update indicator is a small widget shown in the upper right corner of the status bar. It indicates the availability of a newer stable firmware release then the current one. Upon pressing the icon it will automatically update the firmware to the latest stable release. By default this works through the Github Latest Release API. This must be customized should you use a different update server. Have a look at the source file to see what portions to update.</p>"},{"location":"gettingstarted/","title":"Getting Started","text":""},{"location":"gettingstarted/#prerequisites","title":"Prerequisites","text":"<p>This project has quite a complicated build chain to prepare the frontend code for the ESP32. You will need to install some tools to make this all work, starting with a powerful code editor.</p>"},{"location":"gettingstarted/#softwares-to-install","title":"Softwares to Install","text":"<p>Please install the following software, if you haven't already:</p> <ul> <li>VSCode - IDE for development</li> <li>Node.js - For building the interface with npm</li> </ul>"},{"location":"gettingstarted/#vscode-plugins-and-setups","title":"VSCode Plugins and Setups","text":"<p>Please install the following mandatory VSCode Plugins:</p> <ul> <li>PlatformIO - Embedded development platform</li> <li>Prettier - Automated code formatter</li> <li>Svelte for VS Code - Makes working with Svelte much easier</li> <li>Svelte Intellisense - Another Svelte tool</li> <li>Tailwind CSS Intellisense - Makes working with Tailwind CSS much easier</li> <li>Prettier plugin for Tailwind CSS - Automatically sorts the Tailwind classes into their recommended order</li> </ul> <p>Lastly, if you want to make use of Materials for MkDocs as your documentation engine, install Material for MkDocs by typing the following into the VSCode terminal:</p> <pre><code>pip install mkdocs-material\n</code></pre> <p>Tip</p> <p>You might need to run this as administrator, if you getting an error message.</p>"},{"location":"gettingstarted/#project-structure","title":"Project Structure","text":"Resource Description .github/ Github CI pipeline to deploy MkDocs to gh-pages docs/ MkDocs documentation files interface/ SvelteKit based front end lib/framework/ C++ back end for the ESP32 device src/ The main.cpp and demo project to get you started scripts/ Scripts that build the interface as part of the platformio build platformio.ini PlatformIO project configuration file mkdocs.yaml MkDocs project configuration file"},{"location":"gettingstarted/#setting-up-platformio","title":"Setting up PlatformIO","text":""},{"location":"gettingstarted/#setup-build-target","title":"Setup Build Target","text":"<p>Do not use the PlatformIO UI for editing platformio.ini</p> <p>It is tempting to use the PlatformIO user interface to add dependencies or parameters to platformio.ini. However, doing so will remove all \"irrelevant\" information like comments from the file. Please edit the file directly in the editor.</p> <p>platformio.ini is the central file controlling the whole build process. It comes pre-configure with a few boards which have different ESP32 chips. It needs to be adapted to the board you want to program.</p> <pre><code>[platformio]\n...\ndefault_envs = esp32-s3-devkitc-1\n...\n\n[env:adafruit_feather_esp32_v2]\nboard = adafruit_feather_esp32_v2\nboard_build.mcu = esp32\n\n[env:lolin_c3_mini]\nboard = lolin_c3_mini\nboard_build.mcu = esp32c3\n\n[env:esp32-s3-devkitc-1]\nboard = esp32-s3-devkitc-1\nboard_build.mcu = esp32s3\n</code></pre> <p>If your board is not listed in the platformio.ini you may look in the official board list for supported boards and add their information accordingly. Either delete the obsolete <code>[env:...]</code> sections, or change your board as <code>default_envs = ...</code>.</p> <p>Default setup is for an ESP32-S3-DevKitC/M board</p> <p>The projects platformio.ini defaults for an ESP32-S3-DevKitC/M board by Espressif connected to the UART USB port. If you use an other board and the projects shows undesired a behavior it is likely that some parts do not match with pin definitions.</p>"},{"location":"gettingstarted/#build-upload-process","title":"Build &amp; Upload Process","text":"<p>After you've changed platformio.ini to suit your board you can upload the sample code to your board. This will download all ESP32 libraries and execute <code>node install</code> to install all node packages as well. Select your board's environment under the PlatformIO tab and hit <code>Upload and Monitor</code>.</p> <p></p> <p>The first build process will take a while. After a couple of minutes you can see the ESP32 outputting information on the terminal.</p> <p>Use several terminals in parallel</p> <p>VSCode allows you to have more then one terminal running at the same time. You can dedicate one terminal to the serial monitor, while having the development server running in an other terminal.</p>"},{"location":"gettingstarted/#setting-up-sveltekit","title":"Setting up SvelteKit","text":""},{"location":"gettingstarted/#setup-proxy-for-development","title":"Setup Proxy for Development","text":"<p>To ease the frontend development you can deploy the back end code on an ESP32 board and pass the websocket and REST API calls through the development server's proxy. The vite.config.ts file defines the location of the services which the development server will proxy. This is defined by the \"target\" property, which will need to be changed to the the IP address or hostname of the device running the firmware. Change this for both, \"http://\" and \"ws://\".</p> <pre><code>proxy: {\n    // Proxying REST: http://localhost:5173/rest/bar -&gt; http://192.168.1.83/rest/bar\n    '/rest': {\n    target: 'http://192.168.1.83',\n    changeOrigin: true,\n    },\n    // Proxying websockets ws://localhost:5173/ws -&gt; ws://192.168.1.83/ws\n    '/ws': {\n    target: 'ws://192.168.1.83',\n    changeOrigin: true,\n    ws: true,\n    },\n},\n</code></pre> <p>Tip</p> <p>You must restart the development server for changes of the proxy location to come into effect.</p> <p>Tip</p> <p>You can (optionally) speed up the build by commenting out the call to build_interface.py under \"extra scripts\" during local development. This will prevent the npm process from building the production release every time the firmware is compiled significantly decreasing the build time.</p>"},{"location":"gettingstarted/#development-server","title":"Development Server","text":"<p>The interface comes with Vite as a development server. It allows hot module reloading reflecting code changes to the front end instantly in your browser. Open a new terminal session and execute the following commands:</p> <pre><code>cd interface\nnpm run dev\n</code></pre> <p>Follow the link to access the front end in your browser.</p>"},{"location":"gettingstarted/#setup-material-for-mkdocs","title":"Setup Material for mkdocs","text":"<p>Material for MkDocs allows you to create great technical documentation pages just from markup. If you don't want to use it just delete the <code>.github</code> and <code>docs</code> folder, as well as <code>mkdocs.yaml</code>.</p> <p>Otherwise initiate the github CI pipeline by committing and pushing to your repository once. This triggers the automatic build. After a few minutes a new branch <code>gh-pages</code> containing the static website with your documentation should appear. To deploy it go to your github repository go under settings and complete the following steps. </p>"},{"location":"gettingstarted/#development-server_1","title":"Development Server","text":"<p>MkDocs comes with a build-in development server which supports hot reload as well. Open a new terminal session in VSCode and type</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"restfulapi/","title":"RESTful API","text":"<p>The back end exposes a number of API endpoints which are referenced in the table below.</p> Method Request URL Authentication POST JSON Body Info GET /rest/features <code>NONE_REQUIRED</code> none Tells the client which features of the UI should be use GET /rest/otaSettings <code>IS_ADMIN</code> none Retriev current OTA settings POST /rest/otaSettings <code>IS_ADMIN</code> <code>{\"enabled\": true,\"port\": 8266,\"password\": \"esp-sveltekit\"}</code> Update OTA settings GET /rest/mqttStatus <code>IS_AUTHENTICATED</code> none Current MQTT connection status GET /rest/mqttSettings <code>IS_ADMIN</code> none Currently used MQTT settings POST /rest/mqttSettings <code>IS_ADMIN</code> <code>{\"enabled\":false,\"host\":\"test.mosquitto.org\",\"port\":1883,\"username\":\"\",\"password\":\"\",\"client_id\":\"esp32-e89f6d20372c\",\"keep_alive\":60,\"clean_session\":true,\"max_topic_length\":128}</code> Update MQTT settings with new parameters GET /rest/ntpStatus <code>IS_AUTHENTICATED</code> none Current NTP connection status GET /rest/ntpSettings <code>IS_ADMIN</code> none Current NTP settings POST /rest/ntpSettings <code>IS_ADMIN</code> <code>{\"enabled\": true,\"server\": \"time.google.com\",\"tz_label\": \"Europe/London\",\"tz_format\": \"GMT0BST,M3.5.0/1,M10.5.0\"}</code> Update the NTP settings GET /rest/apStatus <code>IS_AUTHENTICATED</code> none Current AP status and client information GET /rest/apSettings <code>IS_ADMIN</code> none Current AP settings POST /rest/apSettings <code>IS_ADMIN</code> <code>{\"provision_mode\": 1,\"ssid\": \"ESP32-SvelteKit-e89f6d20372c\",\"password\": \"esp-sveltekit\",\"channel\": 1,\"ssid_hidden\": false,\"max_clients\": 4,\"local_ip\": \"192.168.4.1\",\"gateway_ip\": \"192.168.4.1\",\"subnet_mask\": \"255.255.255.0\"}</code> Update AP settings GET /rest/wifiStatus <code>IS_AUTHENTICATED</code> none Current status of the wifi client connection GET /rest/scanNetworks <code>IS_ADMIN</code> none Async Scan for Networks in Range GET /rest/listNetworks <code>IS_ADMIN</code> none List networks in range after succesfull scanning. Otherwise triggers scanning. GET /rest/wifiSettings <code>IS_ADMIN</code> none Current WiFi settings POST /rest/wifiSettings <code>IS_ADMIN</code> <code>{\"ssid\":\"YourSSID\",\"password\":\"YourPassword\",\"hostname\":\"esp32-sveltekit\",\"static_ip_config\":false}</code> Udate WiFi settings and credentials GET /rest/systemStatus <code>IS_AUTHENTICATED</code> none Get system informations about the ESP. POST /rest/restart <code>IS_ADMIN</code> none Restart the ESP32 POST /rest/factoryReset <code>IS_ADMIN</code> none Reset the ESP32 and all settings to their default values POST /rest/uploadFirmware <code>IS_ADMIN</code> none File upload of firmware.bin POST /rest/signIn <code>NONE_REQUIRED</code> <code>{\"password\": \"admin\",\"username\": \"admin\"}</code> Signs a user in and returns access token GET /rest/securitySettings <code>IS_ADMIN</code> none retrieves all user information and roles POST /rest/securitySettings <code>IS_ADMIN</code> <code>{\"jwt_secret\": \"734cb5bb-5597b722\", \"users\": [{\"username\": \"admin\", \"password\": \"admin\", \"admin\": true}, {\"username\": \"guest\", \"password\": \"guest\", \"admin\": false, }]</code> retrieves all user information and roles GET /rest/verifyAuthorization <code>NONE_REQUIRED</code> none Verifies the content of the auth bearer token POST /rest/sleep <code>IS_AUTHENTICATED</code> none Puts the device in deep sleep mode POST /rest/downloadUpdate <code>IS_ADMIN</code> <code>{\"download_url\": \"https://github.com/theelims/ESP32-sveltekit/releases/download/v0.1.0/firmware_esp32s3.bin\"}</code> Download link for OTA"},{"location":"statefulservice/","title":"Developing with the Framework","text":"<p>The back end is a set of REST endpoints hosted by a ESPAsyncWebServer instance. The 'lib/framework' directory contains the majority of the back end code. The framework contains a number of useful utility classes which you can use when extending it. The project also comes with a demo project to give you some help getting started.</p> <p>The framework's source is split up by feature, for example WiFiScanner.h implements the end points for scanning for available networks where as WiFiSettingsService.h handles configuring the WiFi settings and managing the WiFi connection.</p>"},{"location":"statefulservice/#initializing-the-framework","title":"Initializing the framework","text":"<p>The 'src/main.cpp' file constructs the webserver and initializes the framework. You can add endpoints to the server here to support your IoT project. The main loop is also accessible so you can run your own code easily.</p> <p>The following code creates the web server and esp32sveltekit framework:</p> <pre><code>AsyncWebServer server(80);\nESP32SvelteKit esp32sveltekit(&amp;server);\n</code></pre> <p>Now in the <code>setup()</code> function the initialization is performed:</p> <pre><code>void setup() {\n  // start serial and filesystem\n  Serial.begin(SERIAL_BAUD_RATE);\n\n  // start the framework and demo project\n  esp32sveltekit.setMDNSAppName(\"ESP32 SvelteKit Demo App\");\n  esp32sveltekit.begin();\n\n  // start the server\n  server.begin();\n}\n</code></pre>"},{"location":"statefulservice/#stateful-service","title":"Stateful Service","text":"<p>The framework promotes a modular design and exposes features you may re-use to speed up the development of your project. Where possible it is recommended that you use the features the frameworks supplies. These are documented in this section and a comprehensive example is provided by the demo project.</p> <p>The following diagram visualizes how the framework's modular components fit together, each feature is described in detail below.</p> <p></p> <p>The StatefulService.h class is responsible for managing state. It has an API which allows other code to update or respond to updates in the state it manages. You can define a data class to hold state, then build a StatefulService class to manage it. After that you may attach HTTP endpoints, WebSockets or MQTT topics to the StatefulService instance to provide commonly required features.</p> <p>Here is a simple example of a state class and a StatefulService to manage it:</p> <pre><code>class LightState {\n public:\n  bool on = false;\n  uint8_t brightness = 255;\n};\n\nclass LightStateService : public StatefulService&lt;LightState&gt; {\n};\n</code></pre> <p>You may listen for changes to state by registering an update handler callback. It is possible to remove an update handler later if required.</p> <pre><code>// register an update handler\nupdate_handler_id_t myUpdateHandler = lightStateService.addUpdateHandler(\n  [&amp;](const String&amp; originId) {\n    Serial.print(\"The light's state has been updated by: \");\n    Serial.println(originId);\n  }\n);\n\n// remove the update handler\nlightStateService.removeUpdateHandler(myUpdateHandler);\n</code></pre> <p>An \"originId\" is passed to the update handler which may be used to identify the origin of an update. The default origin values the framework provides are:</p> Origin Description http An update sent over REST (HttpEndpoint) mqtt An update sent over MQTT (MqttPubSub) websocketserver:{clientId} An update sent over WebSocket (WebSocketServer) <p>StatefulService exposes a read function which you may use to safely read the state. This function takes care of protecting against parallel access to the state in multi-core environments such as the ESP32.</p> <pre><code>lightStateService.read([&amp;](LightState&amp; state) {\n  digitalWrite(LED_PIN, state.on ? HIGH : LOW); // apply the state update to the LED_PIN\n});\n</code></pre> <p>StatefulService also exposes an update function which allows the caller to update the state with a callback. This function automatically calls the registered update handlers if the state has been changed. The example below changes the state of the light (turns it on) using the arbitrary origin \"timer\" and returns the \"CHANGED\" state update result, indicating that a change was made:</p> <pre><code>lightStateService.update([&amp;](LightState&amp; state) {\n   if (state.on) {\n    return StateUpdateResult::UNCHANGED; // lights were already on, return UNCHANGED\n  }\n  state.on = true;  // turn on the lights\n  return StateUpdateResult::CHANGED; // notify StatefulService by returning CHANGED\n}, \"timer\");\n</code></pre> <p>There are three possible return values for an update function which are as follows:</p> Origin Description StateUpdateResult::CHANGED The update changed the state, propagation should take place if required StateUpdateResult::UNCHANGED The state was unchanged, propagation should not take place StateUpdateResult::ERROR There was an error updating the state, propagation should not take place"},{"location":"statefulservice/#serialization","title":"Serialization","text":"<p>When reading or updating state from an external source (HTTP, WebSockets, or MQTT for example) the state must be marshalled into a serializable form (JSON). SettingsService provides two callback patterns which facilitate this internally:</p> Callback Signature Purpose JsonStateReader void read(T&amp; settings, JsonObject&amp; root) Reading the state object into a JsonObject JsonStateUpdater StateUpdateResult update(JsonObject&amp; root, T&amp; settings) Updating the state from a JsonObject, returning the appropriate StateUpdateResult <p>The static functions below can be used to facilitate the serialization/deserialization of the light state:</p> <pre><code>class LightState {\n public:\n  bool on = false;\n  uint8_t brightness = 255;\n\n  static void read(LightState&amp; state, JsonObject&amp; root) {\n    root[\"on\"] = state.on;\n    root[\"brightness\"] = state.brightness;\n  }\n\n  static StateUpdateResult update(JsonObject&amp; root, LightState&amp; state) {\n    state.on = root[\"on\"] | false;\n    state.brightness = root[\"brightness\"] | 255;\n    return StateUpdateResult::CHANGED;\n  }\n};\n</code></pre> <p>For convenience, the StatefulService class provides overloads of its <code>update</code> and <code>read</code> functions which utilize these functions.</p> <p>Read the state to a JsonObject using a serializer:</p> <pre><code>JsonObject jsonObject = jsonDocument.to&lt;JsonObject&gt;();\nlightStateService-&gt;read(jsonObject, LightState::read);\n</code></pre> <p>Update the state from a JsonObject using a deserializer:</p> <pre><code>JsonObject jsonObject = jsonDocument.as&lt;JsonObject&gt;();\nlightStateService-&gt;update(jsonObject, LightState::update, \"timer\");\n</code></pre>"},{"location":"statefulservice/#endpoints","title":"Endpoints","text":"<p>The framework provides an HttpEndpoint.h class which may be used to register GET and POST handlers to read and update the state over HTTP. You may construct an HttpEndpoint as a part of the StatefulService or separately if you prefer.</p> <p>The code below demonstrates how to extend the LightStateService class to provide an unsecured endpoint:</p> <pre><code>class LightStateService : public StatefulService&lt;LightState&gt; {\n public:\n  LightStateService(AsyncWebServer* server) :\n      _httpEndpoint(LightState::read, LightState::update, this, server, \"/rest/lightState\") {\n  }\n\n private:\n  HttpEndpoint&lt;LightState&gt; _httpEndpoint;\n};\n</code></pre> <p>Endpoint security is provided by authentication predicates which are documented below. The SecurityManager and authentication predicate may be provided if a secure endpoint is required. The placeholder project shows how endpoints can be secured.</p>"},{"location":"statefulservice/#persistence","title":"Persistence","text":"<p>FSPersistence.h allows you to save state to the filesystem. FSPersistence automatically writes changes to the file system when state is updated. This feature can be disabled by calling <code>disableUpdateHandler()</code> if manual control of persistence is required.</p> <p>The code below demonstrates how to extend the LightStateService class to provide persistence:</p> <pre><code>class LightStateService : public StatefulService&lt;LightState&gt; {\n public:\n  LightStateService(FS* fs) :\n      _fsPersistence(LightState::read, LightState::update, this, fs, \"/config/lightState.json\") {\n  }\n\n private:\n  FSPersistence&lt;LightState&gt; _fsPersistence;\n};\n</code></pre>"},{"location":"statefulservice/#websockets","title":"WebSockets","text":"<p>WebSocketTxRx.h allows you to read and update state over a WebSocket connection. WebSocketTxRx automatically pushes changes to all connected clients when state is updated.</p> <p>The code below demonstrates how to extend the LightStateService class to provide an unsecured WebSocket:</p> <pre><code>class LightStateService : public StatefulService&lt;LightState&gt; {\n public:\n  LightStateService(AsyncWebServer* server) :\n      _webSocket(LightState::read, LightState::update, this, server, \"/ws/lightState\"), {\n  }\n\n private:\n  WebSocketTxRx&lt;LightState&gt; _webSocket;\n};\n</code></pre> <p>WebSocket security is provided by authentication predicates which are documented below. The SecurityManager and authentication predicate may be provided if a secure WebSocket is required. The placeholder project shows how WebSockets can be secured.</p>"},{"location":"statefulservice/#mqtt","title":"MQTT","text":"<p>The framework includes an MQTT client which can be configured via the UI. MQTT requirements will differ from project to project so the framework exposes the client for you to use as you see fit. The framework does however provide a utility to interface StatefulService to a pair of pub/sub (state/set) topics. This utility can be used to synchronize state with software such as Home Assistant.</p> <p>MqttPubSub.h allows you to publish and subscribe to synchronize state over a pair of MQTT topics. MqttPubSub automatically pushes changes to the \"pub\" topic and reads updates from the \"sub\" topic.</p> <p>The code below demonstrates how to extend the LightStateService class to interface with MQTT:</p> <pre><code>class LightStateService : public StatefulService&lt;LightState&gt; {\n public:\n  LightStateService(AsyncMqttClient* mqttClient) :\n      _mqttPubSub(LightState::read,\n                  LightState::update,\n                  this,\n                  mqttClient,\n                  \"homeassistant/light/my_light/set\",\n                  \"homeassistant/light/my_light/state\") {\n  }\n\n private:\n  MqttPubSub&lt;LightState&gt; _mqttPubSub;\n};\n</code></pre> <p>You can re-configure the pub/sub topics at runtime as required:</p> <pre><code>_mqttPubSub.configureBroker(\"homeassistant/light/desk_lamp/set\", \"homeassistant/light/desk_lamp/state\");\n</code></pre> <p>The demo project allows the user to modify the MQTT topics via the UI so they can be changed without re-flashing the firmware.</p>"},{"location":"statefulservice/#security-features","title":"Security features","text":"<p>The framework has security features to prevent unauthorized use of the device. This is driven by SecurityManager.h.</p> <p>On successful authentication, the /rest/signIn endpoint issues a JSON Web Token (JWT) which is then sent using Bearer Authentication. For this add an <code>Authorization</code>-Header to the request with the Content <code>Bearer {JWT-Secret}</code>. The framework come with built-in predicates for verifying a users access privileges. The built in AuthenticationPredicates can be found in SecurityManager.h and are as follows:</p> Predicate Description NONE_REQUIRED No authentication is required. IS_AUTHENTICATED Any authenticated principal is permitted. IS_ADMIN The authenticated principal must be an admin. <p>You can use the security manager to wrap any request handler function with an authentication predicate:</p> <pre><code>server-&gt;on(\"/rest/someService\", HTTP_GET,\n  _securityManager-&gt;wrapRequest(std::bind(&amp;SomeService::someService, this, std::placeholders::_1), AuthenticationPredicates::IS_AUTHENTICATED)\n);\n</code></pre>"},{"location":"statefulservice/#placeholder-substitution","title":"Placeholder substitution","text":"<p>Various settings support placeholder substitution, indicated by comments in factory_settings.ini. This can be particularly useful where settings need to be unique, such as the Access Point SSID or MQTT client id. The following placeholders are supported:</p> Placeholder Substituted value #{platform} The microcontroller platform, e.g. \"esp32\" or \"esp32c3\" #{unique_id} A unique identifier derived from the MAC address, e.g. \"0b0a859d6816\" #{random} A random number encoded as a hex string, e.g. \"55722f94\" <p>You may use SettingValue::format in your own code if you require the use of these placeholders. This is demonstrated in the demo project:</p> <pre><code>  static StateUpdateResult update(JsonObject&amp; root, LightMqttSettings&amp; settings) {\n    settings.mqttPath = root[\"mqtt_path\"] | SettingValue::format(\"homeassistant/light/#{unique_id}\");\n    settings.name = root[\"name\"] | SettingValue::format(\"light-#{unique_id}\");\n    settings.uniqueId = root[\"unique_id\"] | SettingValue::format(\"light-#{unique_id}\");\n    return StateUpdateResult::CHANGED;\n  }\n</code></pre>"},{"location":"statefulservice/#accessing-settings-and-services","title":"Accessing settings and services","text":"<p>The framework supplies access to various features via getter functions:</p> SettingsService Description getFS() The filesystem used by the framework getSecurityManager() The security manager - detailed above getSecuritySettingsService() Configures the users and other security settings getWiFiSettingsService() Configures and manages the WiFi network connection getAPSettingsService() Configures and manages the Access Point getNTPSettingsService() Configures and manages the network time getOTASettingsService() Configures and manages the Over-The-Air update feature getMqttSettingsService() Configures and manages the MQTT connection getMqttClient() Provides direct access to the MQTT client instance getNotificationEvents() Lets you send push notifications to all clients getSleepService() Send the ESP32 into deep sleep getBatteryService() Update battery information on the client <p>The core features use the StatefulService.h class and can therefore you can change settings or observe changes to settings through the read/update API.</p> <p>Inspect the current WiFi settings:</p> <pre><code>esp32sveltekit.getWiFiSettingsService()-&gt;read([&amp;](WiFiSettings&amp; wifiSettings) {\n  Serial.print(\"The ssid is:\");\n  Serial.println(wifiSettings.ssid);\n});\n</code></pre> <p>Configure the WiFi SSID and password manually:</p> <pre><code>esp32sveltekit.getWiFiSettingsService()-&gt;update([&amp;](WiFiSettings&amp; wifiSettings) {\n  wifiSettings.ssid = \"MyNetworkSSID\";\n  wifiSettings.password = \"MySuperSecretPassword\";\n  return StateUpdateResult::CHANGED;\n}, \"myapp\");\n</code></pre> <p>Observe changes to the WiFiSettings:</p> <pre><code>esp32sveltekit.getWiFiSettingsService()-&gt;addUpdateHandler(\n  [&amp;](const String&amp; originId) {\n    Serial.println(\"The WiFi Settings were updated!\");\n  }\n);\n</code></pre>"},{"location":"statefulservice/#other-functions-provided","title":"Other functions provided","text":""},{"location":"statefulservice/#mdns-instance-name","title":"MDNS Instance Name","text":"<p>ESP32 SvelteKit uses mDNS / Bonjour to advertise its services into the local network. You can set the mDNS instance name property by calling</p> <pre><code>esp32sveltekit.setMDNSAppName(\"ESP32 SvelteKit Demo App\");\n</code></pre> <p>making the entry a little bit more verbose. This must be called before <code>esp32sveltekit.begin();</code>. If you want to advertise further services just include <code>#include &lt;ESPmNDS.h&gt;</code> and use <code>MDNS.addService()</code> regularly.</p>"},{"location":"statefulservice/#factory-reset","title":"Factory Reset","text":"<p>A factory reset can not only be evoked from the API, but also by calling</p> <pre><code>esp32sveltekit.factoryReset();\n</code></pre> <p>from your code. This will erase the complete settings folder, wiping out all settings. This can be a last fall back mode if somebody has forgotten his credentials.</p>"},{"location":"statefulservice/#recovery-mode","title":"Recovery Mode","text":"<p>There is also a recovery mode present which will force the creation of an access point. By calling</p> <pre><code>esp32sveltekit.recoveryMode();\n</code></pre> <p>will force a start of the AP regardless of the AP settings. It will not change the the AP settings. To exit the recovery mode restart the device or change the AP settings in the UI.</p>"},{"location":"statefulservice/#push-notifications-to-all-clients","title":"Push Notifications to All Clients","text":"<p>It is possibly to send push notifications to all clients by using Server Side Events. These will be displayed as toasts an the client side. Either directly call</p> <pre><code>esp32sveltekit.getNotificationEvents()-&gt;pushNotification(\"Pushed a message!\", INFO, millis());\n</code></pre> <p>or keep a local pointer to the <code>NotificationEvents</code> instance. It is possible to send <code>INFO</code>, <code>WARNING</code>, <code>ERROR</code> and <code>SUCCESS</code> events to all clients. The HTTP endpoint for this service is at <code>/events/notifications</code>.</p> <p>In addition the raw <code>send()</code> function is mapped out as well:</p> <pre><code>esp32sveltekit.getNotificationEvents()-&gt;send(\"Pushed a message!\", \"event\", millis());\n</code></pre> <p>This allows you to send your own Server-Sent Events without opening a new HTTP connection.</p>"},{"location":"statefulservice/#power-down-with-deep-sleep","title":"Power Down with Deep Sleep","text":"<p>This API service can place the ESP32 in the lowest power deep sleep mode consuming only a few \u00b5A. It uses the EXT1 wakeup source, so the ESP32 can be woken up with a button or from a peripherals interrupt. Consult the ESP-IDF Api Reference which GPIOs can be used for this. The RTC will also be powered down, so an external pull-up or pull-down resistor is required. It is not possible to persist variable state through the deep sleep. To optimize the deep sleep power consumption it is advisable to use the callback function to put pins with external pull-up's or pull-down's in a special isolated state to prevent current leakage. Please consult the ESP-IDF Api Reference for this.</p> <p>The settings wakeup pin definition and the signal polarity need to be defined in factory_settings.ini:</p> <pre><code>; Deep Sleep Configuration\n-D WAKEUP_PIN_NUMBER=38 ; pin number to wake up the ESP\n-D WAKEUP_SIGNAL=0 ; 1 for wakeup on HIGH, 0 for wakeup on LOW\n</code></pre> <p>A callback function can be attached and triggers when the ESP32 is requested to go into deep sleep. This allows you to safely deal with the power down event. Like persisting software state by writing to the flash, tiding up or notify a remote server about the immanent disappearance.</p> <pre><code>esp32sveltekit.getSleepService()-&gt;attachOnSleepCallback();\n</code></pre> <p>Also the code can initiate the power down deep sleep sequence by calling:</p> <pre><code>esp32sveltekit.getSleepService()-&gt;sleepNow();\n</code></pre>"},{"location":"statefulservice/#battery-state-of-charge","title":"Battery State of Charge","text":"<p>A small helper class let's you update the battery icon in the status bar. This is useful if you have a battery operated IoT device. It must be enabled in features.ini. It uses Server-sent events and exposes two functions that can be used to update the clients.</p> <pre><code>esp32sveltekit.getBatteryService()-&gt;updateSOC(float stateOfCharge); // update state of charge in percent (0 - 100%)\nesp32sveltekit.getBatteryService()-&gt;setCharging(boolean isCharging); // notify the client that the device is charging\n</code></pre>"},{"location":"statefulservice/#custom-features","title":"Custom Features","text":"<p>You may use the compile time feature service also to enable or disable custom features at runtime and thus control the frontend. A custom feature can only be added during initializing the ESP32 and ESP32-SvelteKit. A feature can't be updated on runtime once it is set once.</p> <pre><code>esp32sveltekit.getFeatureService()-&gt;addFeature(\"custom_feature\", true); // or false to disable it\n</code></pre>"},{"location":"statefulservice/#ota-firmware-updates","title":"OTA Firmware Updates","text":"<p>ESP32-SvelteKit offers three different ways to roll out firmware updates to field devices. Except for ArduinoOTA all other OTA possibilities cannot update the file system. If the frontend should be updated as well it is necessary to serve it from PROGMEM by activating <code>-D PROGMEM_WWW</code>.</p>"},{"location":"statefulservice/#arduinoota","title":"ArduinoOTA","text":"<p>Using the ArduinoOTA firmware update service can be enabled by setting <code>FT_OTA=1</code> in features.ini. It creates an update server and advertises it's service through mDNS. This can then be used by the Arduino IDE or Platform.io to flash new firmware directly from the IDE. The defaults are defined in factory_settings.ini, but can be changed at any time through the frontend.</p> <pre><code>  ; OTA settings\n  -D FACTORY_OTA_PORT=8266\n  -D FACTORY_OTA_PASSWORD=\\\"esp-sveltekit\\\"\n  -D FACTORY_OTA_ENABLED=true\n</code></pre>"},{"location":"statefulservice/#firmware-upload","title":"Firmware Upload","text":"<p>Enabling <code>FT_UPLOAD_FIRMWARE=1</code> in features.ini creates a REST endpoint that one can post a firmware binary to. The frontend has a file drop zone to upload a new firmware binary from the browser.</p>"},{"location":"statefulservice/#firmware-download-from-update-server","title":"Firmware Download from Update Server","text":"<p>By enabling <code>FT_DOWNLOAD_FIRMWARE=1</code> in features.ini one can POST a link to a firmware binary which is downloaded for the OTA process. This feature requires SSL and is thus dependent on <code>FT_NTP=1</code>. The Frontend contains an implementation which uses GitHub's Releases section as teh update server. By specifying a firmware version in factory_settings.ini one can make use of semantic versioning to determine the correct firmware:</p> <pre><code>  -D FIRMWARE_VERSION=\\\"0.2.0\\\"\n</code></pre> <p>Attaching the firmware binary from <code>.pio/build/{env}/firmware.bin</code> to the right version tag on GitHub allows anyone to easily upgrade to the latest version.</p> <p>Info</p> <p>This feature could be unstable on single-core members of the ESP32 family.</p>"},{"location":"statefulservice/#custom-update-server","title":"Custom Update Server","text":"<p>If Github is not desired as the update server this can be easily modified to any other custom server. The REST API will accept any valid HTTPS-Link. However, SSL is mandatory and may require a different Root CA Certificate then Github to validate correctly. Follow the instructions here how to change the SSL CA Certificate.</p> <p>If you use a custom update server you must also adapt the frontend code to suit your needs.</p>"},{"location":"stores/","title":"Stores","text":""},{"location":"stores/#user","title":"User","text":"<p>The user store holds the current users credentials, if the security features are enabled. Just import it as you would use with any svelte store:</p> <pre><code>import { user } from \"$lib/stores/user\";\n</code></pre> <p>You can subscribe to it like to any other store with <code>$user</code> and it has the following properties:</p> Property Type Description <code>$user.bearer_token</code> <code>String</code> The JWT token to authorize a user at the back end <code>$user.username</code> <code>String</code> Username of the current user <code>$user.admin</code> <code>Boolean</code> <code>true</code> if the current user has admin privileges <p>In addition to the properties it provides two methods for initializing the user credentials and to invalidate them. <code>data.init()</code> takes a valid JWT toke as an argument and extracts the user privileges and username from it. <code>data.invalidate()</code> invalidates the user credentials and redirects to the login pages</p> <p>User credentials are stored in the browsers local storage</p> <p>The user credentials including the JWT token are stored in the browsers local storage. Any javascript executed on the browser can access this making it extremely vulnerable to XSS attacks. Also the HTTP connection between ESP32 and front end is not encrypted making it possible for everyone to read the JWT token in the same network. Fixing these severe security issues is on the todo list for upcoming releases.</p>"},{"location":"stores/#telemetry","title":"Telemetry","text":"<p>The telemetry store can be used to update telemetry data like RSSI via Server-Sent Events. The corresponding <code>eventListener</code> functions are located in <code>+layout.svelte</code>.</p> <pre><code>import { telemetry } from \"$lib/stores/telemetry\";\n</code></pre> <p>It exposes the following properties you can subscribe to:</p> Property Type Description <code>$telemetry.rssi.rssi</code> <code>Number</code> The RSSI signal strengt of the WiFi in dBm <code>$telemetry.rssi.connected</code> <code>Boolean</code> Connection status of the WiFi <code>$telemetry.battery.soc</code> <code>Number</code> Battery state of charge <code>$telemetry.battery.charging</code> <code>Boolean</code> Is battery connected to charger <code>$telemetry.download_ota.status</code> <code>String</code> Status of OTA <code>$telemetry.download_ota.progress</code> <code>Number</code> Progress of OTA <code>$telemetry.download_ota.error</code> <code>String</code> Error Message of OTA"},{"location":"stores/#analytics","title":"Analytics","text":"<p>The analytics store holds a log of heap and other debug information via Server-Sent Events. The corresponding <code>eventListener</code> functions are located in <code>+layout.svelte</code>.</p> <pre><code>import { analytics } from \"$lib/stores/analytics\";\n</code></pre> <p>It exposes an array of the following properties you can subscribe to:</p> Property Type Description <code>$analytics.uptime</code> <code>Number</code> Uptime of the chip in seconds since last reset <code>$analytics.free_heap</code> <code>Number</code> Current free heap <code>$analytics.min_free_heap</code> <code>Number</code> Minimum free heap that has been <code>$analytics.max_alloc_heap</code> <code>Number</code> Biggest continues free chunk of heap <code>$analytics.fs_used</code> <code>Number</code> Bytes used on the file system <code>$analytics.fs_total</code> <code>Number</code> Total bytes of the file system <code>$analytics.core_temp</code> <code>Number</code> Core temperature (on some chips) <p>By default there is one data point every 2 seconds.</p>"},{"location":"structure/","title":"Customizing the Front End","text":"<p>The actual code for the front end is located under interface/src/ and divided into the \"routes\" folder and a \"lib\" folder for assets, stores and components.</p> Resource Description routes/ Root of the routing system routes/connections/ Setting and status pages for MQTT, NTP, etc. routes/demo/ The lightstate demo routes/system/ Status page for ESP32 and OTA settings routes/user/ Edit and add users and change passwords routes/wifi/ Status and settings for WiFi station and AP lib/ Library folder for stores, components and assets lib/assets/ Assets like pictures lib/components/ Reusable components like modals, password input or collapsible lib/stores Svelte stores for common access to data"},{"location":"structure/#features","title":"Features","text":"<p>The back end provides a JSON which features of the back end are enabled by the feature selection. It is fetched with the page load and made available in the <code>$pages</code>-store and can be accessed on any site with <code>$page.data.features</code>. It is used to hide any disabled setting element.</p>"},{"location":"structure/#delete-demo-project","title":"Delete <code>demo/</code> Project","text":"<p>The light state demo project is included by default to demonstrate the use of the backend and front end. It demonstrates the use of the MQTT-API, websocket API and REST API to switch on the build in LED of the board. routes/connections/mqtt/MQTTConfig.svelte is also part of the 'demo/' Project. You can reuse this to set your own MQTT topics, or delete it. Do not forget to adjust <code>+page.svelte</code> as well. Use it as an example how to create your own custom API and access it from the front end. It can be deleted safely after it has been removed from the menu as well.</p>"},{"location":"structure/#create-your-root-pagesvelte","title":"Create your root <code>+page.svelte</code>","text":"<p>The root page of the front end is located under routes/+page.svelte. This should be the central place of your app and can be accessed at any time by pressing the logo and app name in the side menu. Just override it to suit your needs.</p>"},{"location":"structure/#customize-the-main-menu","title":"Customize the Main Menu","text":"<p>The main menu is located in routes/menu.svelte as a svelte component and defines the main menu including a menu footer.</p>"},{"location":"structure/#menu-footer","title":"Menu Footer","text":"<p>The main menu comes with a small footer to add your copyright notice plus links to github and your discord server where users can find help. The <code>active</code>-flag is used to disable an element in the UI.</p> <pre><code>const appName = \"ESP32 SvelteKit\";\n\nconst copyright = \"2023 theelims\";\n\nconst github = {\n  href: \"https://github.com/\" + $page.data.github,\n  active: true,\n};\n\nconst discord = { href: \".\", active: false };\n</code></pre>"},{"location":"structure/#menu-structure","title":"Menu Structure","text":"<p>The menu consists of an array of menu items. These are defined as follows:</p> <pre><code>{\n    title: 'Demo App',\n    icon: Control,\n    href: '/demo',\n    feature: $page.data.features.project,\n    active: false\n},\n</code></pre> <ul> <li>Where <code>title</code> refers to the page title. It must be identical to <code>$page.data.title</code> as defined in the <code>+page.ts</code> in any of your routes. If they do not match the corresponding menu item is not highlighted on first page load or a page refresh. A minimum <code>+page.ts</code> looks like this:</li> </ul> <pre><code>import type { PageLoad } from \"./$types\";\n\nexport const load = (async ({ fetch }) =&gt; {\n  return {\n    title: \"Demo App\",\n  };\n}) satisfies PageLoad;\n</code></pre> <ul> <li><code>icon</code> must be an icon component giving the menu items icon.</li> <li><code>href</code> is the link to the route the menu item refers to.</li> <li><code>feature</code> takes a bool and should be set to <code>true</code>. It is used by the feature selector to hide a menu entry of it is not present on the back end.</li> <li><code>active</code> takes a bool as well and should be set to <code>false</code> by default. It is automatically set to <code>true</code> to highlight a menu entry as active.</li> </ul>"},{"location":"structure/#advanced-customizations","title":"Advanced Customizations","text":"<p>On the root level there are two more files which you can customize to your needs.</p>"},{"location":"structure/#login-page","title":"Login Page","text":"<p><code>login.svelte</code> is a component showing the login screen, when the security features are enabled. By default it shows the app's logo and the login prompt. Change it as you need it.</p>"},{"location":"structure/#status-bar","title":"Status Bar","text":"<p><code>statusbar.svelte</code> contains the top menu bar which you can customize to show state information about your app and IoT device. By default it shows the active menu title and the hamburger icon on small screens.</p>"},{"location":"structure/#github-firmware-update","title":"Github Firmware Update","text":"<p>If the feature <code>FT_DOWNLOAD_FIRMWARE</code> is enabled, ESP32 SvelteKit pulls the Github Release section through the Github API for firmware updates (stable only) once per hour. Also the firmware update menu shows all available firmware releases allowing the user to up- and downgrade has he pleases. If you're using the Github releases section you must first tell the frontend your correct path to your github repository as described here.</p> <p>Also you must make use of the '-D FIRMWARE_VERSION=' flag in factory_settings.ini and give it the same semantic version number as the release tag on Github. On Github create a new release with the matching tag name. Attach the firmware binary file found under <code>.pio/build/{env}/firmware.bin</code>. The frontend searches for the first attachment found and uses this as the update link. If you upload further attachments the binary must be the first element, otherwise the update will fail.</p>"},{"location":"structure/#custom-update-server","title":"Custom Update Server","text":"<p>The frontend and backend code can be easily adjusted to suit a custom update server. For the backend the changes are described here. On the frontend only two files must be adapted and changed to switch to a custom update server: /lib/components/UpdateIndicator.svelte and /routes/system/update/GithubFirmwareManager.svelte.</p> <p>Info</p> <p>The update server must provide the firmware download through SSL encryption.</p>"},{"location":"sveltekit/","title":"Getting Started with SvelteKit","text":"<p>SvelteKits unique approach makes it perfect suitable for constraint server. It builds very small files shipping only the minimum required amount of java script. This keeps the memory footprint low so that rich applications can be build with just the 4MB flash of many ESP32 chips.</p> <p>However, since SvelteKit is designed with server-side rendering first, there are some catches and pitfalls one must avoid. Especially as nearly all tutorials found on SvelteKit heavily make use of the combined front and back end features.</p>"},{"location":"sveltekit/#limitations-of-adapter-static","title":"Limitations of <code>adapter-static</code>","text":"<p>To build a website that can be served from an ESP32 <code>adapter-static</code> is used. This means no server functions can be used. The front end is build as a Single-Page Application (SPA) instead. However, SvelteKit will pre-render sites at build time, even if SSR and pre-rendering are disabled. This leads to some restrictions that must be taken into consideration:</p> <ul> <li> <p>You can't use any server-side logic like <code>+page.server.ts</code>, <code>+layout.server.ts</code> or <code>+server.ts</code> files in your project.</p> </li> <li> <p>The load function in <code>+page.ts</code> gets executed on the server and the client. If you try to access browser resources in the load function this will fail. Use a more traditional way like fetching the data in the <code>+page.svelte</code> with the <code>onMount(() =&gt; {})</code> callback.</p> </li> </ul>"},{"location":"sveltekit/#customizing-and-theming","title":"Customizing and Theming","text":""},{"location":"sveltekit/#changing-the-app-name","title":"Changing the App Name","text":"<p>To change the app name first adjust it in the +layout.ts file:</p> <pre><code>export const load = (async () =&gt; {\n    const result = await fetch('/rest/features');\n    const item = await result.json();\n    return {\n        features: item,\n        title: 'ESP32-SvelteKit',\n        github: 'theelims/ESP32-sveltekit'\n    };\n}) satisfies LayoutLoad;\n</code></pre> <p>While you're at it update <code>github</code> to your repository. It will be used by the link to your repository by the menu footer, as well querying the Github API for firmware updates.</p> <p>Then change the app name in the menu.svelte file as well.</p> <pre><code>const appName = \"ESP32 SvelteKit\";\n</code></pre> <p>There is also a manifest file which contains the app name to use when adding the app to a mobile device, so you may wish to also edit interface/static/manifest.json:</p> <pre><code>{\n  \"name\": \"ESP32 SvelteKit\",\n  \"icons\": [\n    {\n      \"src\": \"/favicon.png\",\n      \"sizes\": \"48x48 72x72 96x96 128x128 256x256\"\n    }\n  ],\n  \"start_url\": \"/\",\n  \"display\": \"fullscreen\",\n  \"orientation\": \"any\"\n}\n</code></pre>"},{"location":"sveltekit/#changing-the-app-icon-and-favicon","title":"Changing the App Icon and Favicon","text":"<p>You can replace the apps favicon which is located at interface/static/favicon.png with one of your preference. A 256 x 256 PNG is recommended for best compatibility.</p> <p>Also the Svelte Logo can be replaced with your own. It is located under interface/src/lib/assets/logo.png.</p>"},{"location":"sveltekit/#daisy-ui-themes","title":"Daisy UI Themes","text":"<p>The overall theme of the front end is defined by DaisyUI and can be easily changed according to their documentation. Either by selecting one of the standard themes of DaisyUI, or creating your own. By default the <code>corporate</code> and <code>business</code> for dark are defined in tailwind.config.cjs:</p> <pre><code>    daisyui: {\n        themes: ['corporate', 'business'],\n        darkTheme: 'business'\n    }\n</code></pre>"},{"location":"sveltekit/#opinionated-use-of-shadows","title":"Opinionated use of Shadows","text":"<p>The front end makes some use of colored shadows with the <code>shadow-primary</code> and <code>shadow-secondary</code> DaisyUI classes. Just use the search and replace function to change this to a more neutral look, if you find the color too much.</p>"}]}